// in your main HTML document.
var rng_state; var rng_pool; var rng_pptr; 
// Mix in a 32-bit integer into the pool function
rng_seed_int(x) { rng_pool[rng_pptr++] ^= x & 255; rng_pool[rng_pptr++] ^= (x >> 8) & 255; rng_pool[rng_pptr++] ^= (x >> 16) & 255; rng_pool[rng_pptr++] ^= (x >> 24) & 255; if(rng_pptr >= rng_psize) rng_pptr -= rng_psize; } 
// Mix in the current time (w/milliseconds) into the pool function rng_seed_time() { rng_seed_int(new Date().getTime()); }
// Initialize the pool with junk if needed.
if(rng_pool == null) { rng_pool = new Array(); rng_pptr = 0; var t; if(navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) { // Extract entropy (256 bits) from NS4 RNG if available var z = window.crypto.random(32); for(t = 0; t < z.length; ++t) rng_pool[rng_pptr++] = z.charCodeAt(t) & 255; } while(rng_pptr < rng_psize) { // extract some randomness from Math.random() t = Math.floor(65536 * Math.random()); rng_pool[rng_pptr++] = t >>> 8; rng_pool[rng_pptr++] = t & 255; } rng_pptr = 0; rng_seed_time(); //rng_seed_int(window.screenX); //rng_seed_int(window.screenY); } 
    function rng_get_byte() { if(rng_state == null) { rng_seed_time(); rng_state = prng_newstate(); rng_state.init(rng_pool); for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) rng_pool[rng_pptr] = 0; rng_pptr = 0; //rng_pool = null; }
// TODO: allow reseeding after first request
return rng_state.next(); }
function rng_get_bytes(ba) { var i; for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte(); }
    function SecureRandom() {} SecureRandom.prototype.nextBytes = rng_get_bytes; 
    // Copyright (c) 2005 Tom Wu // All Rights Reserved. // See "LICENSE" for details. // Basic JavaScript BN library - subset useful for RSA encryption. // Bits per digit var dbits; // JavaScript engine analysis
    var canary = 0xdeadbeefcafe; var j_lm = ((canary&0xffffff)==0xefcafe); // (public) Constructor function BigInteger(a,b,c) { if(a != null) if("number" == typeof a) this.fromNumber(a,b,c); else if(b == null && "string" != typeof a) this.fromString(a,256); else this.fromString(a,b); } // return new, unset BigInteger function nbi() { return new BigInteger(null); } // am: Compute w_j += (x*this_i), propagate carries, // c is initial carry, returns final carry. // c < 3*dvalue, x < 2*dvalue, this_i < dvalue // We need to select the fastest one that works in this environment. // am1: use a single mult and divide to get the high bits, // max digit bits should be 26 because // max internal value = 2*dvalue^2-2*dvalue (< 2^53) function am1(i,x,w,j,c,n) { while(--n >= 0) { var v = x*this[i++]+w[j]+c; c = Math.floor(v/0x4000000); w[j++] = v&0x3ffffff; } return c; } // am2 avoids a big mult-and-extract completely. // Max digit bits should be <= 30 because we do bitwise ops // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31) function am2(i,x,w,j,c,n) { var xl = x&0x7fff, xh = x>>15; while(--n >= 0) { var l = this[i]&0x7fff; var h = this[i++]>>15; var m = xh*l+h*xl; l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff); c = (l>>>30)+(m>>>15)+xh*h+(c>>>30); w[j++] = l&0x3fffffff; } return c; } // Alternately, set max digit bits to 28 since some // browsers slow down when dealing with 32-bit numbers. function am3(i,x,w,j,c,n) { var xl = x&0x3fff, xh = x>>14; while(--n >= 0) { var l = this[i]&0x3fff; var h = this[i++]>>14; var m = xh*l+h*xl; l = xl*l+((m&0x3fff)<<14)+w[j]+c; c = (l>>28)+(m>>14)+xh*h; w[j++] = l&0xfffffff; } return c; } if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) { BigInteger.prototype.am = am2; dbits = 30; } else if(j_lm && (navigator.appName != "Netscape")) { BigInteger.prototype.am = am1; dbits = 26; } else { // Mozilla/Netscape seems to prefer am3 BigInteger.prototype.am = am3; dbits = 28; } BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = ((1<= 0; --i) r[i] = this[i]; r.t = this.t; r.s = this.s; } // (protected) set from integer value x, -DV <= x < DV function bnpFromInt(x) { this.t = 1; this.s = (x<0)?-1:0; if(x > 0) this[0] = x; else if(x < -1) this[0] = x+DV; else this.t = 0; } // return bigint initialized to value function nbv(i) { var r = nbi(); r.fromInt(i); return r; } // (protected) set from string and radix function bnpFromString(s,b) { var k; if(b == 16) k = 4; else if(b == 8) k = 3; else if(b == 256) k = 8; // byte array else if(b == 2) k = 1; else if(b == 32) k = 5; else if(b == 4) k = 2; else { this.fromRadix(s,b); return; } this.t = 0; this.s = 0; var i = s.length, mi = false, sh = 0; while(--i >= 0) { var x = (k==8)?s[i]&0xff:intAt(s,i); if(x < 0) { if(s.charAt(i) == "-") mi = true; continue; } mi = false; if(sh == 0) this[this.t++] = x; else if(sh+k > this.DB) { this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<>(this.DB-sh)); } else this[this.t-1] |= x<= this.DB) sh -= this.DB; } if(k == 8 && (s[0]&0x80) != 0) { this.s = -1; if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)< 0 && this[this.t-1] == c) --this.t; } // (public) return string representation in given radix function bnToString(b) { if(this.s < 0) return "-"+this.negate().toString(b); var k; if(b == 16) k = 4; else if(b == 8) k = 3; else if(b == 2) k = 1; else if(b == 32) k = 5; else if(b == 4) k = 2; else return this.toRadix(b); var km = (1< 0) { if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); } while(i >= 0) { if(p < k) { d = (this[i]&((1<>(p+=this.DB-k); } else { d = (this[i]>>(p-=k))&km; if(p <= 0) { p += this.DB; --i; } } if(d > 0) m = true; if(m) r += int2char(d); } } return m?r:"0"; } // (public) -this function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; } // (public) |this| function bnAbs() { return (this.s<0)?this.negate():this; } // (public) return + if this > a, - if this < a, 0 if equal function bnCompareTo(a) { var r = this.s-a.s; if(r != 0) return r; var i = this.t; r = i-a.t; if(r != 0) return r; while(--i >= 0) if((r=this[i]-a[i]) != 0) return r; return 0; } // returns bit length of the integer x function nbits(x) { var r = 1, t; if((t=x>>>16) != 0) { x = t; r += 16; } if((t=x>>8) != 0) { x = t; r += 8; } if((t=x>>4) != 0) { x = t; r += 4; } if((t=x>>2) != 0) { x = t; r += 2; } if((t=x>>1) != 0) { x = t; r += 1; } return r; } // (public) return the number of bits in "this" function bnBitLength() { if(this.t <= 0) return 0; return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM)); } // (protected) r = this << n*DB function bnpDLShiftTo(n,r) { var i; for(i = this.t-1; i >= 0; --i) r[i+n] = this[i]; for(i = n-1; i >= 0; --i) r[i] = 0; r.t = this.t+n; r.s = this.s; } // (protected) r = this >> n*DB function bnpDRShiftTo(n,r) { for(var i = n; i < this.t; ++i) r[i-n] = this[i]; r.t = Math.max(this.t-n,0); r.s = this.s; } // (protected) r = this << n function bnpLShiftTo(n,r) { var bs = n%this.DB; var cbs = this.DB-bs; var bm = (1<= 0; --i) { r[i+ds+1] = (this[i]>>cbs)|c; c = (this[i]&bm)<= 0; --i) r[i] = 0; r[ds] = c; r.t = this.t+ds+1; r.s = this.s; r.clamp(); } // (protected) r = this >> n function bnpRShiftTo(n,r) { r.s = this.s; var ds = Math.floor(n/this.DB); if(ds >= this.t) { r.t = 0; return; } var bs = n%this.DB; var cbs = this.DB-bs; var bm = (1<>bs; for(var i = ds+1; i < this.t; ++i) { r[i-ds-1] |= (this[i]&bm)<>bs; } if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<>= this.DB; } if(a.t < this.t) { c -= a.s; while(i < this.t) { c += this[i]; r[i++] = c&this.DM; c >>= this.DB; } c += this.s; } else { c += this.s; while(i < a.t) { c -= a[i]; r[i++] = c&this.DM; c >>= this.DB; } c -= a.s; } r.s = (c<0)?-1:0; if(c < -1) r[i++] = this.DV+c; else if(c > 0) r[i++] = c; r.t = i; r.clamp(); } // (protected) r = this * a, r != this,a (HAC 14.12) // "this" should be the larger one if appropriate. function bnpMultiplyTo(a,r) { var x = this.abs(), y = a.abs(); var i = x.t; r.t = i+y.t; while(--i >= 0) r[i] = 0; for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t); r.s = 0; r.clamp(); if(this.s != a.s) BigInteger.ZERO.subTo(r,r); } // (protected) r = this^2, r != this (HAC 14.16) function bnpSquareTo(r) { var x = this.abs(); var i = r.t = 2*x.t; while(--i >= 0) r[i] = 0; for(i = 0; i < x.t-1; ++i) { var c = x.am(i,x[i],r,2*i,0,1); if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) { r[i+x.t] -= x.DV; r[i+x.t+1] = 1; } } if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1); r.s = 0; r.clamp(); } // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20) // r != q, this != m. q or r may be null. function bnpDivRemTo(m,q,r) { var pm = m.abs(); if(pm.t <= 0) return; var pt = this.abs(); if(pt.t < pm.t) { if(q != null) q.fromInt(0); if(r != null) this.copyTo(r); return; } if(r == null) r = nbi(); var y = nbi(), ts = this.s, ms = m.s; var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); } var ys = y.t; var y0 = y[ys-1]; if(y0 == 0) return; var yt = y0*(1<1)?y[ys-2]>>this.F2:0); var d1 = this.FV/yt, d2 = (1<= 0) { r[r.t++] = 1; r.subTo(t,r); } BigInteger.ONE.dlShiftTo(ys,t); t.subTo(y,y);	// "negative" y so we can replace sub with am later while(y.t < ys) y[y.t++] = 0; while(--j >= 0) { // Estimate quotient digit var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2); if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out y.dlShiftTo(j,t); r.subTo(t,r); while(r[i] < --qd) r.subTo(t,r); } } if(q != null) { r.drShiftTo(ys,q); if(ts != ms) BigInteger.ZERO.subTo(q,q); } r.t = ys; r.clamp(); if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder if(ts < 0) BigInteger.ZERO.subTo(r,r); } // (public) this mod a function bnMod(a) { var r = nbi(); this.abs().divRemTo(a,null,r); if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r); return r; } // Modular reduction using "classic" algorithm function Classic(m) { this.m = m; } function cConvert(x) { if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m); else return x; } function cRevert(x) { return x; } function cReduce(x) { x.divRemTo(this.m,null,x); } function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); } function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); } Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; // (protected) return "-1/this % 2^DB"; useful for Mont. reduction // justification: // xy == 1 (mod m) // xy = 1+km // xy(2-xy) = (1+km)(1-km) // x[y(2-xy)] = 1-k^2m^2 // x[y(2-xy)] == 1 (mod m^2) // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2 // should reduce x and y(2-xy) by m^2 at each step to keep size bounded. // JS multiply "overflows" differently from C/C++, so care is needed here. function bnpInvDigit() { if(this.t < 1) return 0; var x = this[0]; if((x&1) == 0) return 0; var y = x&3;	// y == 1/x mod 2^2 y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4 y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8 y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16 // last step - calculate inverse mod DV directly; // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints y = (y*(2-x*y%this.DV))%this.DV;	// y == 1/x mod 2^dbits // we really want the negative inverse, and -DV < y < DV return (y>0)?this.DV-y:-y; } // Montgomery reduction function Montgomery(m) { this.m = m; this.mp = m.invDigit(); this.mpl = this.mp&0x7fff; this.mph = this.mp>>15; this.um = (1<<(m.DB-15))-1; this.mt2 = 2*m.t; } // xR mod m function montConvert(x) { var r = nbi(); x.abs().dlShiftTo(this.m.t,r); r.divRemTo(this.m,null,r); if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r); return r; } // x/R mod m function montRevert(x) { var r = nbi(); x.copyTo(r); this.reduce(r); return r; } // x = x/R mod m (HAC 14.32) function montReduce(x) { while(x.t <= this.mt2)	// pad x so am has enough room later x[x.t++] = 0; for(var i = 0; i < this.m.t; ++i) { // faster way of calculating u0 = x[i]*mp mod DV var j = x[i]&0x7fff; var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM; // use am to combine the multiply-shift-add into one call j = i+this.m.t; x[j] += this.m.am(0,u0,x,i,0,this.m.t); // propagate carry while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; } } x.clamp(); x.drShiftTo(this.m.t,x); if(x.compareTo(this.m) >= 0) x.subTo(this.m,x); } // r = "x^2/R mod m"; x != r function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); } // r = "xy/R mod m"; x,y != r function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); } Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; // (protected) true iff this is even function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; } // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79) function bnpExp(e,z) { if(e > 0xffffffff || e < 1) return BigInteger.ONE; var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1; g.copyTo(r); while(--i >= 0) { z.sqrTo(r,r2); if((e&(1< 0) z.mulTo(r2,g,r); else { var t = r; r = r2; r2 = t; } } return z.revert(r); } // (public) this^e % m, 0 <= e < 2^32 function bnModPowInt(e,m) { var z; if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m); return this.exp(e,z); } // protected BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; // public BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; // "constants" BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1); // Depends on jsbn.js and rng.js // convert a (hex) string to a bignum object function parseBigInt(str,r) { return new BigInteger(str,r); } function linebrk(s,n) { var ret = ""; var i = 0; while(i + n < s.length) { ret += s.substring(i,i+n) + "\n"; i += n; } return ret + s.substring(i,s.length); } function byte2Hex(b) { if(b < 0x10) return "0" + b.toString(16); else return b.toString(16); } // *************** custom addition - begin *****************/ // PKCS#1 (type 1,FF) pad input string s to n bytes, and return a bigint // Custom addition to origianl rsa.js function pkcs1pad1(s,n) { if(n < s.length + 11) { alert("Message too long for RSA"); return null; } var ba = new Array(); ba[--n] = 0; // as if adding null to the string to be padded var i = s.length - 1; while(i >= 0 && n > 0) ba[--n] = s.charCodeAt(i--); ba[--n] = 0; while(n > 2) { ba[--n] = 0xFF; } ba[--n] = 1; ba[--n] = 0; return new BigInteger(ba); } // *************** custom addition - end ******************/ // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint function pkcs1pad2(s,n) { if(n < s.length + 11) { //alert("Message too long for RSA");	// **** custom addition - line commented return null; } var ba = new Array(); // *************** custom addition - begin *****************/ ba[--n] = 0; // as if adding null to the string to be padded // *************** custom addition - end ******************/ var i = s.length - 1; while(i >= 0 && n > 0) ba[--n] = s.charCodeAt(i--); ba[--n] = 0; var rng = new SecureRandom(); var x = new Array(); while(n > 2) { // random non-zero pad x[0] = 0; while(x[0] == 0) rng.nextBytes(x); ba[--n] = x[0]; } ba[--n] = 2; ba[--n] = 0; return new BigInteger(ba); } // "empty" RSA key constructor function RSAKey() { this.n = null; this.e = 0; this.d = null; this.p = null; this.q = null; this.dmp1 = null; this.dmq1 = null; this.coeff = null; // *************** custom addition - begin ******************/ this.publicKeyInit = false; // *************** custom addition - end ******************/ } // Set the public key fields N and e from hex strings function RSASetPublic(N,E) { if(N != null && E != null && N.length > 0 && E.length > 0) { this.n = parseBigInt(N,16); this.e = parseInt(E,16); // *************** custom addition - begin ******************/ this.publicKeyInit = true; // custom addition // *************** custom addition - end ******************/ } else { //alert("Invalid RSA public key"); // **** custom addition - line commented this.publicKeyInit = false; // custom addition } } // Perform raw public operation on "x": return x^e (mod n) function RSADoPublic(x) { return x.modPowInt(this.e, this.n); } // Return the PKCS#1 RSA encryption of "text" as an even-length hex string function RSAEncrypt(text) { var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3); if(m == null) return null; var c = this.doPublic(m); if(c == null) return null; var h = c.toString(16); if((h.length & 1) == 0) return h; else return "0" + h; } // *************** custom addition - begin ******************/ // Return the PKCS#1 RSA encryption of "text" according to specific pad type and len // Custom addition to original rsa.js function RSAEncryptEx(text,padType,padLen) { var m; switch (padType) { case 1: m = pkcs1pad1(text,padLen); break; case 2: m = pkcs1pad2(text,padLen); break; default: return null; } if(m == null) return null; var c = this.doPublic(m); if(c == null) return null; var h = c.toString(16); if((h.length & 1) == 0) return h; else return "0" + h; } // *************** custom addition - end ******************/ // Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string //function RSAEncryptB64(text) { // var h = this.encrypt(text); // if(h) return hex2b64(h); else return null; //} // protected RSAKey.prototype.doPublic = RSADoPublic; // public RSAKey.prototype.setPublic = RSASetPublic; RSAKey.prototype.encrypt = RSAEncrypt; RSAKey.prototype.encryptEx = RSAEncryptEx;	// custom addition to original rsa.js //RSAKey.prototype.encrypt_b64 = RSAEncryptB64; /* ********************* END OF JSBN/RSA CODE *************************** */ window.cpRSA = function() { //this.ENCRYPT_LENGTH = 128; //this.PKCS1_PADDING_TYPE = 1;	// 1 - FF, 2 - Random this.isPublicKeySet = false; this.m = "";	// part of public key this.e = "";	// part of public key this.token = null; // if login requires to encrypt password with token this.isAuthenticated = false; // for captive portal use - in case this session is already authenticated this.orgUrl = ""; // for captive portal use this.oRSAkey = null; this.rsaCB = function(){} /* ***************************************************************** */ this.initPublicKey = function() { this.oRSAkey = new RSAKey();	// jsbn library DEBUG.out('RSA: calling server to get public key.'); sendAsynchronousRequest('RSASettings','',this.savePublicKey,this); } /* ***************************************************************** */ /* ***************************************************************** */ this.isReadyToEncrypt = function() { return this.isPublicKeySet; } /* ***************************************************************** */ /* ***************************************************************** */ this.savePublicKey = function(xhrStatus, xhrResponse) { if (xhrStatus != 200) { DEBUG.out('RSA: get Settings failed. ('+xhrStatus+')', DEBUG.ERROR); this.isPublicKeySet = false; //alert("RSA Error!"); return; } var rsaJSONObj = JSON.parse(xhrResponse); this.m = rsaJSONObj.m; this.e = rsaJSONObj.e; if (!isNothingness(rsaJSONObj.loginToken)) { this.token = rsaJSONObj.loginToken; } if (!isNothingness(rsaJSONObj.isAuthenticated)) { this.isAuthenticated = rsaJSONObj.isAuthenticated; } else { this.isAuthenticated = false; } if (!isNothingness(rsaJSONObj.orgUrl)) { this.orgUrl = rsaJSONObj.orgUrl; } else { this.orgUrl = ""; } // init inner rsa object this.oRSAkey.setPublic(this.m,this.e); // making sure rsa settngs are valid this.isPublicKeySet = this.oRSAkey.publicKeyInit; if (!this.isPublicKeySet) { DEBUG.out('savePublicKey: RSA public key invalid!\nm(' + this.m +')\ne(' + this.e + ')',DEBUG.ERROR); } this.rsaCB(); } /* ***************************************************************** */ /* ***************************************************************** */ this.updatePublicKey = function(e, m) { this.m = m; this.e = e; // init inner rsa object this.oRSAkey.setPublic(this.m,this.e); // making sure rsa settngs are valid this.isPublicKeySet = this.oRSAkey.publicKeyInit; if (!this.isPublicKeySet) { DEBUG.out('updatePublicKey: RSA public key invalid!\nm(' + this.m +')\ne(' + this.e + ')',DEBUG.ERROR); } } /* ***************************************************************** */ /* ***************************************************************** */ this.encrypt = function(text) { // Try update keys from cookies. var e = getCookie("RSASetting_e"); var m = getCookie("RSASetting_m"); if ((!isNothingness(e)) && (!isNothingness(m))) { DEBUG.out('Update RSA keys from cookie.'); this.updatePublicKey(e, m); } if (!this.isPublicKeySet) // did you call this.initPublicKey? { DEBUG.out('Did you call initPublicKey? Did it fail?',DEBUG.ERROR); return ""; } text = unescape( encodeURIComponent( text ) ); if (!isNothingness(this.token)) { text = this.token + text; } // call the ecryption itself var value = this.oRSAkey.encrypt(text); if (value.length > 2) { var newPass = ""; for (var j=value.length-2; j>=0; j=j-2) { newPass = newPass.concat(value.substr(j,2)); } value = newPass; } return value; } /* ***************************************************************** */ } window.cpRSAobj = new cpRSA(); window.cpRSAobj.initPublicKey(); //============================================================================================= // Includes END // Set namespace. PORTAL_IS.VALIDATOR = {}; //============================================================================================= PORTAL_IS.VALIDATOR.Validity = function() { this.isValid = true; this.message = ""; this.opaque = null; } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.ValidatorStack = function() { this.validatorStack = new Array(); this.invalidMessage = ""; // Add valkidator to the stack. this.add = function(validator) { this.validatorStack.push(validator); } // Empty the validator stack. this.clear = function() { this.validatorStack = new Array(); } // Set a single message for invalidity. The message will override any of the validators' // messages. this.setInvalidMessage = function(message) { this.invalidMessage = message; } // Evaluate the stack. Retutn a Validity object. this.evaluate = function(value) { var validity = new PORTAL_IS.VALIDATOR.Validity(); var i; var validatorStackSize = this.validatorStack.length; // Check each validator. for (i=0; ((validity.isValid)&&(i= 1)); // Assign messages. if (!validity.isValid) { validity.message = this.messageArr[0]; } // Extra stuff. // Return validity. return validity; } // Set defaults. this.setMessage(0, "Value may not be empty."); } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsUnderMaxLength = function() { // args=[max length, inclusive] // defaults: [0, true] this.validatingMethod = function(value) { var validity = new PORTAL_IS.VALIDATOR.Validity(); var inclusive = (isNothingness(this.argArr[1]) ? true : this.argArr[1] ); // Check validity. validity.isValid = (!isNothingness(value) && ( inclusive ? (value.length <= this.argArr[0]) : (value.length < this.argArr[0]) )); // Assign messages. if (!validity.isValid) { validity.message = this.messageArr[0]; } // Extra stuff. // Return validity. return validity; } // Set defaults. this.setMessage(0, "Value length should be under :"+this.argArr[1]); } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsNumeric = function() { this.validatingMethod = function(value) { var validity = new PORTAL_IS.VALIDATOR.Validity(); // Check validity. validity.isValid = !isNaN(value); // Assign messages. if (!validity.isValid) { validity.message = this.messageArr[0]; } // Extra stuff. // Return validity. return validity; } // Set defaults. this.setMessage(0, "Value must be numeric."); } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsInteger = function() { this.validatingMethod= function(value) { var validity = new PORTAL_IS.VALIDATOR.Validity(); // Check validity. validity = new PORTAL_IS.VALIDATOR.IsNumeric().validate(value); // Check if numeric. if (validity.isValid) { validity.isValid = (parseInt(value) == value); // Assign messages. if (!validity.isValid) { validity.message = this.messageArr[0]; } } // Return validity. return validity; } // Set defaults. this.setMessage(0, "Value must be an integer."); } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsNumberInRange = function() { // args=[lower, upper, inclusive] // To ommit any of the limits pass null. // Examples: // value > 0 => arge=[0, null, false] // value <= 0 => arge=[null, 0, true] // Default args: [ null, null, false] this.validatingMethod= function(value) { if (isNothingness(this.argArr)) { this.argArr = [null, null, false]; } var lowerLimit = (isNothingness(this.argArr[0]) ? null : this.argArr[0]); var upperLimit = (isNothingness(this.argArr[1]) ? null : this.argArr[1]); var inclusive	= (this.argArr[2] == true); var validity = new PORTAL_IS.VALIDATOR.Validity(); // Check validity. validity = new PORTAL_IS.VALIDATOR.IsNumeric().validate(value); // Check if numeric. if ((!isNothingness(this.argArr[0])) && (validity.isValid)) { if (!(validity.isValid = (inclusive ? (value >= this.argArr[0]) : (value > this.argArr[0])) )) { // Assign messages. validity.message = this.messageArr[0]; } } // Check validity. if ((!isNothingness(this.argArr[1])) && (validity.isValid)) { if (!(validity.isValid = (inclusive ? (value <= this.argArr[1]) : (value < this.argArr[1])) )) { // Assign messages. validity.message = this.messageArr[1]; } } // Return validity. return validity; } // Set defaults. this.setMessage(0, "Value is below valid range."); this.setMessage(1, "Value is above valid range."); this.setArgArr([null, null, false]); // Set no range and exclusive. } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsPositiveNumber = function() { // Set defaults. this.setMessage(0, "Value must be a positive integer."); this.setArgArr([0, null, false]); // ==> value > 0 } //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.IsNegativeNumber = function() { // Set defaults. this.setMessage(0, "Value must be a negative integer."); this.setArgArr([null, 0, false]); // ==> value < 0 } //============================================================================================= //============================================================================================= // Extend Validator. PORTAL_IS.VALIDATOR.IsNotEmpty.prototype = new PORTAL_IS.VALIDATOR.Validator(); PORTAL_IS.VALIDATOR.IsUnderMaxLength.prototype = new PORTAL_IS.VALIDATOR.Validator(); PORTAL_IS.VALIDATOR.IsNumeric.prototype = new PORTAL_IS.VALIDATOR.Validator(); PORTAL_IS.VALIDATOR.IsInteger.prototype = new PORTAL_IS.VALIDATOR.Validator(); PORTAL_IS.VALIDATOR.IsNumberInRange.prototype	= new PORTAL_IS.VALIDATOR.Validator(); // Extend others validators. PORTAL_IS.VALIDATOR.IsPositiveNumber.prototype = new PORTAL_IS.VALIDATOR.IsNumberInRange(); PORTAL_IS.VALIDATOR.IsNegativeNumber.prototype = new PORTAL_IS.VALIDATOR.IsNumberInRange(); //============================================================================================= //============================================================================================= PORTAL_IS.VALIDATOR.evaluateValidatorStack = function(validatorStack, value) { var validity = new PORTAL_IS.VALIDATOR.Validity(); var i; var validatorStackSize = validatorStack.length; for (i=0; ((validity.isValid)&&(i -1) { hashObj.view = hash.substr(0, splitPoint); if (hash.length > splitPoint) { try { hashObj.data = JSON.parse($.base64Decode(hash.substring(splitPoint+1, hash.length))); } catch (e) { DEBUG.out('ViewManager::parseHash Error while parsing hash data.', DEBUG.ERROR, e); } } } else if (hash != "") { hashObj.view = this.hash2View(hash); } return hashObj; } //================================================================================================================== //================================================================================================================== this.changeHash = function(view, data, quietly) { DEBUG.out('ViewManager::changeHash.'); if (isNothingness(quietly)) { quietly = false; } if (quietly) { DEBUG.out('ViewManager::changeHash, Changing hash quietly.'); viewManager.ignoreHashChange = true; } $(window).history('add', this.generateHash(view, data)); } //================================================================================================================== }	/* ________________________________________________________________________________________________________________________ PORTAL IS - ESSENTIALS INCLUSION - END ======================================================================================================================== */ // NAC's view manager. window.NacViewManager = function() { this.lastRenderedCustomContentContainers = new Array(); this.callback = new Callback(); // Get state with it's View (CSS, JS and HTML). // Will call upon callback when done rendering the view. // In case the returned view is of the given "suppressedViewName" it's view render will be ignored. //============================================================================================= this.gotoNextState = function(callback, suppressedViewName, delayInterval) { DEBUG.out("ViewManager::gotoNextState"); if (callback == undefined) { callback = new Callback(); } if (isNothingness(suppressedViewName)) { suppressedViewName = ""; } var sAbsoluteURL = getURL("GetStateAndView"); var params = ""; var cb = new Callback(); cb.methodReference = this.handleNewView; cb.thisArgument = this; cb.args = [callback, suppressedViewName,delayInterval]; PORTAL_IS.AJAX_MGR.sendAsyncReq(sAbsoluteURL,params,cb,this.errorHandler); } //============================================================================================= // Get view contents (CSS, JS and HTML). // Will call upon callback when done rendering the view. //============================================================================================= this.gotoView = function(view, callback) { if (callback == undefined) { callback = new Callback(); } DEBUG.out("ViewManager::gotoView ("+view+")"); // fetch the org url var sAbsoluteURL = getURL("GetViewData"); var params = "view="+view; var cb = new Callback(); cb.methodReference = this.handleNewView; cb.thisArgument = this; cb.args = [callback]; PORTAL_IS.AJAX_MGR.sendAsyncReq(sAbsoluteURL,params,cb,this.errorHandler); } //============================================================================================= //============================================================================================= this.errorHandler = function(portalException, callback) { DEBUG.out('NAC Access: ViewManager request failed. ' + 'PortalException:' + portalException.errMsg, DEBUG.ERROR); //if (portalException.portalErrorType == PortalErrorType.NETWORK_TIMEOUT) if (portalException.portalErrorType != PortalErrorType.BAD_XHR_STATUS) { alert(portalException.errMsg + " Please try reloading the page."); return; } } //============================================================================================= //============================================================================================= this.handleNewView = function(xhrStatus, xhrResponse, callback, suppressedViewName, delayInterval) { if (callback == undefined) { callback = new Callback(); } if (xhrStatus != 200) { // TODO: Handle error. DEBUG.out('Retreiving view failed. ('+xhrStatus+')', DEBUG.ERROR); callback.call(); return; } var newViewJSONObj = JSON.parse(xhrResponse); var newView = newViewJSONObj.view; DEBUG.out("Parsed from JSON - view:" + newView); if (suppressedViewName == newView) { this.callback = callback; setTimeout("window.viewManager.callback.call()", delayInterval); DEBUG.out('NacViewManager::handleNewView - suppressing view changes ' + delayInterval); //callback.call(); return; }	// if there is a suppressed view name, just not in this stage else if (suppressedViewName != undefined && suppressedViewName != "") { callback = new Callback(); } var useDefaultContainerId = true; var requiredContainerId = ""; var requiredView = ""; var viewCallback = ""; switch (newView) { // Login Sequence View group ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ case "Authentication": viewCallback = "window.oAuthentication.onRender()"; case "Agreement": case "Final": case "Error": case "AgentChoice": case "Agent": case "AgentInstalled": case "SignOff": useDefaultContainerId = false; requiredContainerId = "LoginSequencePage_Content"; requiredView = "LoginSequenceView"; break; default: // View will be rendered into main page view. useDefaultContainerId = true; /* DEBUG.out('Render new view ('+newViewJSONObj.view+') into default location.'); evaluateCSS(newViewJSONObj.css, getURL("css/" + newViewJSONObj.view)); evaluateHTMLContent(newViewJSONObj.html); evaluateJavaScript(newViewJSONObj.javascript); */ break; } // Check if the Main View is already rendered. if ( useDefaultContainerId || ( (document.getElementById(requiredContainerId) != undefined) && (document.getElementById(requiredContainerId) != null) ) ) { DEBUG.out('Render new view ('+newViewJSONObj.view+') into ' + (useDefaultContainerId ? "DefaultContainer" : requiredContainerId) + "."); // Render CSS. evaluateCSS(newViewJSONObj.css, getURL("css/" + newViewJSONObj.view)); // Render HTML Content. var destinationRef; if (useDefaultContainerId) { destinationRef = document.getElementById("portal_main_view"); //evaluateHTMLContent(newViewJSONObj.html); } else { destinationRef = document.getElementById(requiredContainerId); } destinationRef.style.display = "none"; evaluateHTMLContent(newViewJSONObj.html, destinationRef); // Render JavaScript Content. // might add content to html (like realms) evaluateJavaScript(newViewJSONObj.javascript); // Render custom content. // todo : see is we want to implement this xxx this.getViewCustomContent(newViewJSONObj.view); destinationRef.style.display = "block"; if (viewCallback) { eval(viewCallback); //setTimeout(containerCallback,0); } } else { DEBUG.out('Main View needs to be rendered first.'); // Set the previous view results in a callback, it will be called when finished rendering of the login sequence page. var requiredViewCallback = new Callback(); requiredViewCallback.methodReference = this.handleNewView; requiredViewCallback.thisArgument = this; requiredViewCallback.args = [200, xhrResponse]; // Set fake status and response. // Request specific view. this.gotoView(requiredView, requiredViewCallback); } // Done here, call the callback. callback.call(); } //============================================================================================= // Get the view's custom Content. //============================================================================================= this.getViewCustomContent = function(view) { var userAgent = window.navigator.userAgent.toLowerCase(); if ((userAgent.indexOf("iphone") != -1) || (userAgent.indexOf("ndroid") != -1) || (userAgent.indexOf("ipod") != -1) ) { // no custom content in iphone return; } this.clearLastCustomContent(); // fetch the org url var sAbsoluteURL = getURL("viewManager/GetViewCustomContent"); var params = "view="+view; var cb = new Callback(); cb.methodReference = this.renderCustomContent; cb.thisArgument = this; PORTAL_IS.AJAX_MGR.sendAsyncReq(sAbsoluteURL,params,cb); } //============================================================================================= // Render the custom content. //============================================================================================= this.renderCustomContent = function(xhrStatus, xhrResponse, callbackObj) { DEBUG.out('Render custom content.'); callback = new Callback(callbackObj); if (xhrStatus != 200) { // TODO: Handle error. DEBUG.out('Retreiving custom content failed. ('+xhrStatus+')', DEBUG.ERROR); callback.call(); return; } // The container Id is: "CustomContent__". // For example: the "ISW" view and the resource key of "top" will be rendered into "CustomContent_ISW_top". var newCustomContentJSONObj = JSON.parse(xhrResponse); var keyArr = newCustomContentJSONObj.keyMap; var view = newCustomContentJSONObj.view // you could choose a different view for different states var usedView = "LoginSequencePage"; // Iterate on each of the custom content object. var customContent, containerId, key; //for (var key in keyMap) for (key in keyArr) { customContent = keyArr[key]; containerId = "CustomContent_"+usedView+"_"+key; DEBUG.out('Render custom content: usedView:['+usedView+"] into:["+containerId+"]"); this.evaluateCustomContent(customContent, containerId); this.lastRenderedCustomContentContainers.push(containerId); } // Call the callback. callback.call(); } // Encapsulate conditional rendering of the custom content. this.evaluateCustomContent = function(customContent, containerId) { destinationRef = document.getElementById(containerId); if ( (destinationRef != null) && (destinationRef != undefined) ) { evaluateHTMLContent(customContent, destinationRef); } } //============================================================================================= // Clear last rendered containers. //============================================================================================= this.clearLastCustomContent = function() { for (var containerIndex in this.lastRenderedCustomContentContainers) { this.evaluateCustomContent(" ", this.lastRenderedCustomContentContainers[containerIndex]); } this.lastRenderedCustomContentContainers = new Array(); } //============================================================================================= //Changes the button CSS class (workaround for IE6-8). this.setButtonState = function(state,button) { var correctClass = "class"; if(window.browserDetails.browserType == window.BrowserType.IE && window.browserDetails.browserVersion <= 7 && document.documentMode === undefined) { correctClass = "className"; } if(button.getAttribute(correctClass).indexOf("disabled") == -1) { //The button is not disabled. button.setAttribute(correctClass, "button" + state); } } } // Extend ViewManager (Portal IS). NacViewManager.prototype = new ViewManager(); window.viewManager = new NacViewManager(); var isTabActive = true; window.onfocus = function () { isTabActive = true; }; window.onblur = function () { isTabActive = false; }; createPageClosingWarningOnfocus = function() { if (window.isTabActive) { return pageClosingWarning(); } else { return; } }